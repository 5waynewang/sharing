<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=1024, user-scalable=no">

  <title>如何设计一款MQ</title>

  <!-- Required stylesheet -->
  <link rel="stylesheet" media="screen" href="../../deck.js/core/deck.core.css">

  <!-- Extension CSS files go here. Remove or add as needed. -->
  <link rel="stylesheet" media="screen" href="../../deck.js/extensions/goto/deck.goto.css">
  <link rel="stylesheet" media="screen" href="../../deck.js/extensions/menu/deck.menu.css">
  <link rel="stylesheet" media="screen" href="../../deck.js/extensions/navigation/deck.navigation.css">
  <link rel="stylesheet" media="screen" href="../../deck.js/extensions/status/deck.status.css">
  <link rel="stylesheet" media="screen" href="../../deck.js/extensions/scale/deck.scale.css">

  <!-- Style theme. More available in /themes/style/ or create your own. -->
  <link rel="stylesheet" media="screen" href="../../deck.js/themes/style/web-2.0.css">

  <!-- Transition theme. More available in /themes/transition/ or create your own. -->
  <link rel="stylesheet" media="screen" href="../../deck.js/themes/transition/horizontal-slide.css">

  <!-- Basic black and white print styles -->
  <link rel="stylesheet" media="print" href="../../deck.js/core/print.css">

  <!-- Required Modernizr file -->
  <script src="../../deck.js/modernizr.custom.js"></script>
</head>
<body>
  <div class="deck-container">

    <!-- Begin slides. Just make elements with a class of slide. -->

    <section class="slide" id="index">
      <h2>如何设计一款MQ？</h2>
      <ol>Name : 王伟</ol>
      <ol>Department : 智能金融</ol>
	  <ol>Email : hzwangwei6@corp.netease.com</ol>
    </section>
	
    <section class="slide" id="what-mq">
      <h2>MQ是什么？</h2>
	  <ol>Message Queue 消息队列</ol>
    </section>
	
    <section class="slide" id="how-mq-do">
      <h2>MQ能做什么？</h2>

      <ul>
        <li>
          <strong>解耦</strong>：
		  面向"消息"的编程
        </li>

        <li>
          <strong>异步</strong>：
		  MQ把一次RPC调用变2次RPC调用，让"处理"变"通知"
        </li>
		
        <li>
          <strong>削峰</strong>：
		  消息堆积
        </li>
		
        <li>
          <strong>最终一致</strong>：
		  业务依托MQ做最终一致
        </li>
		
        <li>
          <strong>广播</strong>：
		  一次"生产"，多方"订阅"
        </li>
      </ul>
    </section>
	
    <section class="slide" id="mq-word">
      <h2>MQ的一些术语</h2>
	  
      <img src="./images/simple-mq-relation.png" alt="SimpleMQRelation">

      <ul>
        <li>
          <strong>Topic</strong>: 消息主题，表示一类消息。
        </li>
		
        <li>
          <strong>Producer</strong>: 消息生产者，负责产生消息，一般由业务系统负责产生消息。
        </li>
		
        <li>
          <strong>Consumer Group</strong>: 一类Consumer的集合名称，这类Consumer通常消费一类消息，且消费逻辑一致。
        </li>
		
        <li>
          <strong>Consumer</strong>: 消息消费者，负责消费消息，一般是后台系统负责异步消费。
        </li>
		
        <li>
          <strong>Broker</strong>: 消息中转角色，负责存储消息，转发消息，一般也称为Server。
        </li>
      </ul>
    </section>
	
    <section class="slide" id="how-design-pefect-ms">
      <h2>想象下：一个完整的MQ服务应该具备什么？</h2>
	  <p class="slide" id="DesignPefectMQ-img">
      <img src="./images/DesignPefectMQ.png" alt="DesignPefectMQ">
	  </p>
    </section>
	
    <section class="slide" id="mq-feature-list">
      <h2>想象下：一个完整的MQ服务应该具备什么？</h2>

      <ul>
        <li>
          <strong>MQ服务会有多个broker，可以根据策略做负载均衡</strong>
        </li>

        <li>
          <strong>broker要保证高可用，挂了一台也会有其它的broker顶上，所以broker要有备份</strong>
        </li>
		
        <li>
          <strong>同一类(Topic)消息分布到不同的broker、不同的队列</strong>
        </li>
		
        <li>
          <strong>需要维护每个队列的生产进度、消费者与每个队列的消费进度</strong>
        </li>
		
        <li>
          <strong>保证消息的可靠性，需要有方案不会丢消息</strong>
        </li>

        <li>
          <strong>消息的堆积方案</strong>
        </li>

        <li>
          <strong>... ...</strong>
        </li>
      </ul>

      <p class="slide" id="mq-feature-list-memo">下面将从底层开始介绍，如何从单个队列到多个队列，从单机到集群的逐步实现过程，由于时间有限，本篇仅以文件队列为基础展开介绍。</p>
    </section>

	<section class="slide" id="singleTopicSingleQueue-img">
      <h2>单队列实现发布订阅</h2>
	  <p>单队列：一个topic对应一个Queue</p>
      <img src="./images/singleQueue.png" alt="singleTopicSingleQueue">
    </section>

    <section class="slide" id="singleTopicSingleQueue-remark">
      <h2>单队列实现发布订阅</h2>

      <ul>
        <li>
          <strong>I/O</strong>: 顺序读写文件
        </li>

        <li>
          <strong>消息存储</strong>: 同步、异步、定期、定量
        </li>

        <li>
          <strong>消息结构</strong>: offset定义
		  <img src="./images/message-design.png" alt="message-design">
        </li>
		
        <li>
          <strong>Topic关系维护</strong>: Topic与Queue的关系、Queue的写offset
        </li>
		
        <li>
          <strong>消费关系维护</strong>: Consumer、Topic、Queue、读offset
        </li>
		
        <li>
          <strong>消费模型</strong>: pull/push
        </li>

        <li>
          <strong>消息堆积</strong>: 消息过期策略
        </li>
      </ul>

      <p class="slide" id="singleTopicSingleQueue-remark-memo">这块东西可以单独抽出来作为java.util.Queue的实现类使用，适合那些担心应用重启会丢消息的场景，比方说：异步请求的失败重试</p>
    </section>

	<section class="slide" id="singleTopicSingleQueue-img2">
      <h2>单队列实现发布订阅</h2>
      <img src="./images/singleQueue.png" alt="singleTopicSingleQueue">
	  <h2>单机情况下如何优化演进？</h2>
    </section>
	
    <section class="slide" id="singleTopicMultiQueue-remark">
      <h2>多队列模型</h2>
	  <p>单队列是一个topic对应一个Queue，演进后一个topic则有多个Queue</p>
	  <h3 class="slide" id="singleTopicMultiQueue-remark-optimize">这样做的好处呢？</h3>
      <ul class="slide" id="singleTopicMultiQueue-remark-optimize-list">
        <li>
          <strong>负载均衡</strong>: 多个队列，分摊生产、消费请求
        </li>
		
        <li>
          <strong>安全性</strong>: 数据分区存放，有一定的保护作用
        </li>
      </ul>
    </section>

    <section class="slide" id="consumeMode">
      <h2>消费模型</h2>
	  <ul>
        <li>
          <strong>集群消费</strong>: 一个Consumer Group中的Consumer实例平均分摊消费消息。例如某个Topic有9条消息，其中一个Consumer Group有3个实例（可能是3个进程，或者3台机器），那么每个实例只消费其中的3条消息。
        </li>
		
        <li>
          <strong>广播消费</strong>: 一条消息被多个Consumer消费，即使这些Consumer属于同一个Consumer Group，消息也会被Consumer Group中的每个Consumer都消费一次，广播消费中的Consumer Group概念可以认为在消息划分方面无意义。
        </li>
      </ul>
    </section>

	<section class="slide" id="singleTopicMultiQueue-clusterConsuming-img">
      <h2>多队列-集群消费模型</h2>
      <img src="./images/patition-clusterConsuming.png" alt="singleTopicMultiQueue-clusterConsuming">
    </section>
	
    <section class="slide" id="singleTopicMultiQueue-clusterConsuming-remark">
      <h2>多队列-集群消费模型</h2>
      <ul>		
        <li>
          <strong>Topic关系维护</strong>: Topic与Queue的关系、每个Queue的写offset
        </li>

        <li>
          <strong>消费关系维护</strong>: Consumer group对每个Queue的消费进度（其下每个Consumer需要共享消费进度，所以消费进度需要统一管理）
        </li>
		
        <li>
          <strong>负载均衡</strong>: Producer轮询写，Consumer平均消费
        </li>
      </ul>
    </section>
	
	<section class="slide" id="singleTopicMultiQueue-broadcastConsuming-img">
      <h2>多队列-广播消费模型</h2>
      <img src="./images/patition-broadcastConsuming.png" alt="singleTopicMultiQueue-broadcastConsuming">
    </section>
	
    <section class="slide" id="singleTopicMultiQueue-broadcastConsuming-remark">
      <h2>多队列-广播消费模型</h2>
	  <p>与集群消费不同的点：</p>
      <ul>
        <li>
          <strong>消费关系维护</strong>: Consumer对每个Queue的消费进度（消费进度存放在消费端本地即可）
        </li>
		
        <li>
          <strong>负载均衡</strong>: Producer轮询写，Consumer全部消费（无法loadbalance）
        </li>
      </ul>
	  
	  <h2 class="slide" id="singleTopicMultiQueue-broadcastConsuming-remark-optimize">单机还能优化吗？</h2>
    </section>
	
    <section class="slide" id="single-optimize-patition">
      <h2>kafka分区数过多的问题</h2>
	  <p class="slide" id="kafka-many-patition">顺序读、写变随机读、写</p>
	  <p class="slide" id="RocketMQ-offset">RocketMQ解决方案：
      <img src="./images/RocketMQ-offset.png" alt="RocketMQOffset"></p>
	  <p class="slide" id="RocketMQ-many-patition">问题：顺序读变随机读(同一topic消息在commit log中不是连续的)，会影响消费的吞吐量吗？</p>
    </section>
	
    <section class="slide" id="single-optimize-other">
	  <h2>单机还能优化吗？</h2>
	  
      <ul>
        <li class="slide" id="cluster-optimize-other-mem">
          <strong>内存优化</strong>: 增加内存
        </li>
		
        <li class="slide" id="cluster-optimize-other-mem">
          <strong>硬件支持</strong>: 部署多块磁盘、用固态硬盘(成本高)
        </li>
		
        <li class="slide" id="cluster-optimize-other-hard">
          <strong>磁盘读写优化</strong>: raid(成本高)
        </li>
		
        <li class="slide" id="cluster-optimize-other-design">
          <strong>设计上优化</strong>: <p class="slide" id="cluster-optimize-other-design-non">想不出来？</p>
        </li>
      </ul>
	  <h2 class="slide" id="single-to-cluster">如何从单机到集群？</h2>
    </section>
	
	<section class="slide" id="cluster-role">
      <h2>MQ集群角色</h2>
	  
      <ul>
        <li>
          <strong>Broker</strong>: 存储消息，转发消息，server
        </li>
		
        <li>
          <strong>注册中心</strong>: 服务发现，Topic关系维护，消费关系维护，offset维护
        </li>
		
        <li>
          <strong>Producer</strong>: 消息生产者，生产消息
        </li>
		
        <li>
          <strong>Consumer</strong>: 消息消费者，消费消息
        </li>
      </ul>

      <img src="./images/cluster-role-relation.png" alt="clusterRoleRelation" class="slide" id="cluster-role-relation">
    </section>

	<section class="slide" id="clusterTopicMultiQueue-img">
      <h2>MQ集群模型</h2>
      <img src="./images/clusterMQ-pc.png" alt="clusterTopicMultiQueue">
    </section>
	
    <section class="slide" id="clusterTopicMultiQueue-remark">
      <h2>MQ集群模型</h2>

      <ul>
        <li>
          <strong>RPC通信</strong>: NIO TCP、协议
        </li>

        <li>
          <strong>服务发现</strong>: 注册中心
        </li>
		
        <li>
          <strong>负载均衡</strong>: Topic、Broker、Queue
        </li>
		
		<li>
          <strong>消费关系</strong>: Consumer、Topic、Queue、offset
		  <br>
		  1. Broker维护消费进度
		  <br>
		  2. Consumer维护消费进度
        </li>
		
        <li>
          <strong>消费模型pull/push</strong>: 双重保证，通知push、消费pull
        </li>
      </ul>
	  
	  <h2 class="slide" id="clusterTopicMultiQueue-remark-cluster">如何做高可用？</h2>
    </section>
	
	<section class="slide" id="MQ-HA-img">
      <h2>MQ高可用模型</h2>
      <img src="./images/MQ-HA-pc.png" alt="MQ-HA-Producer-Consumer">
    </section>
	
    <section class="slide" id="MQ-HA-remark">
      <h2>MQ高可用模型</h2>

      <ul>
        <li>
          <strong>HA部署模式</strong>: Master/Slave、Leader Election
        </li>

        <li>
          <strong>failover</strong>: replica broker、replica queue
        </li>
		
        <li>
          <strong>replication策略</strong>: 同步commit、异步pull by offset
        </li>
      </ul>
    </section>
	
	<section class="slide" id="just-MQ-img">
      <h2>MQ仅仅如此？</h2>
      <img src="./images/think.jpg" alt="just-MQ">
    </section>
	
	<section class="slide" id="MQ-features">
      <h2>MQ难点剖析</h2>
	  
      <ul>
        <li>
          <strong>投递策略</strong>
        </li>

        <li>
          <strong>可靠性</strong>
        </li>

        <li>
          <strong>顺序消息</strong>
        </li>

        <li>
          <strong>重复消息</strong>
        </li>

        <li>
          <strong>事务消息</strong>
        </li>

        <li>
          <strong>辅助功能</strong>
        </li>
      </ul>
	  
    </section>
	
	<section class="slide" id="Delivery-policies">
      <h2>投递策略</h2>
	  
      <ul>
        <li>
          <strong>最多一次（At most Once ）</strong>: 
		  <img src="./images/At-most-Once.png" alt="At-most-Once">
		  <p class="slide" id="At-most-Once-remark">消息可能会丢，但绝不会重复传输</p>
        </li>

        <li class="slide" id="At-least-Once">
          <strong>最少一次（At least Once）</strong>: 
		  <p class="slide" id="At-least-Once-remark">消息绝不会丢，但可能会重复传输</p>
        </li>

        <li class="slide" id="Exactly-Once">
          <strong>仅有一次（Exactly Once）</strong>: 每条消息肯定会被传输一次且仅传输一次，很多时候这是用户所想要的。
        </li>
      </ul>
	  
    </section>
	
	<section class="slide" id="message-ack">
      <h2>可靠性</h2>
	  <p>可用性、持久化、确认机制</p>
	  <h2 class="slide" id="how-design-message-ack">如何设计可靠的确认机制？</h2>
      <ul>
        <li class="slide" id="message-ack-athread-sync">
          <strong>单线程同步ack</strong>: 同步更新offset
		  <p>
		  这里的单线程是指单线程消费同一队列/分区
		  <br>
		  1.单条消息消费
		  <br>
		  2.多条消息顺序消费
		  </p>
        </li>
		
        <li class="slide" id="message-ack-athread-async">
          <strong>单线程异步ack</strong>: 适合pull模型
		  <p>
		  1.pull带上offset
		  <br>
		  2.Consumer异步维护offset(ack)
		  </p>
        </li>

        <li class="slide" id="message-ack-multithread-sync">
          <strong>多线程同步ack</strong>: 适合push模型
		  <p>这里的多线程是指多个线程(可以在不同的进程)消费同一队列/分区</p>
        </li>

        <li class="slide" id="message-ack-multithread-async">
          <strong>多线程异步ack</strong>: 得不偿失
        </li>
      </ul>
    </section>
	
	<section class="slide" id="orderly-message">
      <h2>顺序消息</h2>
	  
      <ul>
        <li class="slide" id="orderly-message-select-patition">
          <strong>投递顺序</strong>: 自定义Producer的loadbalance规则，让一类消息投递到同一个Queue中
		  <p class="slide" id="orderly-message-select-patition-remark">网络分区很难保证！！！</p>
        </li>
		
        <li class="slide" id="orderly-message-sorted">
          <strong>消息排序</strong>: 消息本身有序
		  <p class="slide" id="orderly-message-sorted-design">
		  <img src="./images/sorted-message.png" alt="Sorted Message">
		  </p>
        </li>
      </ul>
      <h4 class="slide" id="how-design-timing-message">？？？定时消息如何实现？？？</h4>
    </section>
	
	<section class="slide" id="repeated-message">
      <h2>重复消息</h2>
	  <img src="./images/At-most-Once.png" alt="At-most-Once">
	  <p class="slide" id="repeated-message-design">给消息弄个ID，去重！！！</p>
      <ul>
        <li class="slide" id="repeated-message-p1">
          <strong>Broker去重</strong>
        </li>

        <li class="slide" id="repeated-message-p2">
          <strong>Consumer去重（幂等）</strong>
        </li>
      </ul>
    </section>
	
	<section class="slide" id="transactional-message">
      <h2>事务消息</h2>
	  <img src="./images/transactional-message.png" alt="TransactionalMessage">
      <ul>
        <li class="slide" id="transactional-message-p1">
          <strong>消息需要二阶段提交</strong>
        </li>

        <li class="slide" id="transactional-message-p2">
          <strong>Broker需要记录事务状态</strong>
        </li>

        <li class="slide" id="transactional-message-p3">
          <strong>Broker需要回查Producer状态</strong>
        </li>

        <li class="slide" id="transactional-message-p4">
          <strong>Producer需要记录事务状态</strong>
        </li>
      </ul>
    </section>
	
	<section class="slide" id="message-tools">
      <h2>辅助功能</h2>
	  
      <ul>
        <li class="slide" id="message-index">
          <strong>消息索引</strong>: 查询消息
        </li>
		
        <li class="slide" id="message-recall">
          <strong>消息回溯</strong>: offset、时间
        </li>

        <li class="slide" id="message-trace">
          <strong>消息轨迹</strong>: 消息的生命周期
        </li>
      </ul>
    </section>
	
	<section class="slide" id="questions">
      <h2>常见问题</h2>
	  
      <ul>
        <li class="slide" id="questions-consume-error">
          <strong>消息误消费</strong>: 环境问题，设置错误
		  <p>
		  eg：预发和线上共用同一个MQ，consumer group又是同一个
		  </p>
        </li>

        <li class="slide" id="questions-lost-message">
          <strong>丢消息</strong>: 
		  <p>
		  1.ACK确认失败
		  <br>
		  2.消费超时(次数、时间)
		  <br>
		  3.设置错误，RocketMQ同一consumer group消费不同的Topic
		  </p>
        </li>
		
        <li class="slide" id="questions-lost-monitor">
          <strong>消息监控</strong>: 
		  <p>
		  1.MQ监控
		  <br>
		  2.业务方监控(Producer、Consumer)
		  </p>
        </li>
      </ul>
    </section>
	
	<section class="slide" id="thanks">
		<h2>Thanks</h2>
		<ol>Q/A</ol>
		<ol>如果您觉得还不错，还请关注微信公众号：</ol>
		<img src="../../resources/images/qrcode_for_gh_0630ba0d9494_344.jpg" alt="微信公众号">
		<ol>微信扫描上方二维码，或者搜索并关注微信公众号： 以山之名</ol>
    </section>

    <!-- End slides. -->

    <!-- Begin extension snippets. Add or remove as needed. -->

    <!-- deck.navigation snippet -->
    <div aria-role="navigation">
      <a href="#" class="deck-prev-link" title="Previous">&#8592;</a>
      <a href="#" class="deck-next-link" title="Next">&#8594;</a>
    </div>

    <!-- deck.status snippet -->
    <p class="deck-status" aria-role="status">
      <span class="deck-status-current"></span>
      /
      <span class="deck-status-total"></span>
    </p>

    <!-- deck.goto snippet -->
    <form action="." method="get" class="goto-form">
      <label for="goto-slide">Go to slide:</label>
      <input type="text" name="slidenum" id="goto-slide" list="goto-datalist">
      <datalist id="goto-datalist"></datalist>
      <input type="submit" value="Go">
    </form>

    <!-- End extension snippets. -->
  </div>

<!-- Required JS files. -->
<script src="../../deck.js/jquery.min.js"></script>
<script src="../../deck.js/core/deck.core.js"></script>

<!-- Extension JS files. Add or remove as needed. -->
<script src="../../deck.js/extensions/menu/deck.menu.js"></script>
<script src="../../deck.js/extensions/goto/deck.goto.js"></script>
<script src="../../deck.js/extensions/status/deck.status.js"></script>
<script src="../../deck.js/extensions/navigation/deck.navigation.js"></script>
<script src="../../deck.js/extensions/scale/deck.scale.js"></script>

<!-- Initialize the deck. You can put this in an external file if desired. -->
<script>
  $(function() {
    $.deck('.slide');
  });
</script>
</body>
</html>
